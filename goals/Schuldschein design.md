# 1 Schuldanerkenntniss standart
## 1.1
```
SCHULDANERKENNTNIS
UND RATENZAHLUNGSVEREINBARUNG

zwischen

________________________________________________ ________________________________________________
- nachfolgend „Schuldner“ genannt -

und
________________________________________________ ________________________________________________
 - nachfolgend „Gläubiger“ genannt -

1. Hiermit erkennt der Schuldner zur selbstständigen Begründung der Zahlungsverpflichtung und unter Ausschluss jeglicher bekannter oder für möglich erachteter Einwendungen gegen die durch diesen Vertrag begründete Forderung an, dass er dem Gläubiger einen Betrag in Höhe von ________________ € (nachfolgend der „Schuldbetrag“) schuldet. Diser setzt sich aus dem ursprünglich ?geschuldetem? Betrag sowie einer vereinbarten Gebührt von ____ (____% des ursprünglich geschuldetem Betrages) zusammen. Der Schuldbetrag wird nicht verzinst.
2. Der Schuldner erteilt dem Gläubiger hiermit das Mandat, die fälligen monatlichen Raten in Höhe von ______________ € jeweils am ___. Tag eines Monats, erstmals am ___. ______________ _____, mittels SEPA-Lastschrift von folgendem Konto einzuziehen:

Kontoinhaber: ________________________  
IBAN: ________________________  
BIC: ________________________  
Kreditinstitut: ________________________

Der Gläubiger überträgt die Einziehung der fälligen Beträge an [Name der Inkassofirma oder Kanzlei], die im Namen und Auftrag des Gläubigers handelt. Der Schuldner erklärt sich einverstanden, dass die persönlichen Daten und Vertragsdetails zu diesem Zweck an die genannte Partei übermittelt werden.

Dieses SEPA-Lastschriftmandat gilt für die gesamte Laufzeit des Schuldanerkenntnisses. Der Schuldner verpflichtet sich, für ausreichende Deckung auf dem angegebenen Konto zu sorgen. Der Gläubiger wird den Schuldner mindestens 1 Werktag vor jeder Abbuchung über den Betrag und den Termin der Belastung (Pre-Notification) informieren.

Das Mandat kann vom Schuldner jederzeit schriftlich widerrufen werden. In diesem Fall ist der Schuldner verpflichtet, die monatlichen Raten fristgerecht auf andere Weise zu leisten.

Der Schuldner erkennt an, dass ein Widerruf des SEPA-Lastschriftmandats nicht die Zahlungspflicht oder die Verpflichtung zur ordnungsgemäßen Rückzahlung des Schuldbetrags aufhebt. Im Falle eines Widerrufs wird die Einziehung der fälligen Beträge an [Name der Kanzlei/Inkassobüro/Plattform] übertragen, die berechtigt ist, alle zur Eintreibung erforderlichen Maßnahmen durchzuführen.





```









## 1.2

```
SCHULDANERKENNTNIS
UND RATENZAHLUNGSVEREINBARUNG

zwischen

________________________________________________ ________________________________________________
- nachfolgend „Schuldner“ genannt -

und
________________________________________________ ________________________________________________
 - nachfolgend „Gläubiger“ genannt -




1. Hiermit erkennt der Schuldner zur selbstständigen Begründung der Zahlungsverpflichtung und unter Ausschluss jeglicher bekannter oder für möglich erachteter Einwendungen gegen die durch diesen Vertrag begründete Forderung an, dass er dem Gläubiger einen Betrag in Höhe von ________________ € (nachfolgend der „Schuldbetrag“) schuldet. Diser setzt sich aus dem ursprünglich ?geschuldetem? Betrag sowie einer vereinbarten Gebührt von ____ (____% des ursprünglich geschuldetem Betrages) zusammen. Der Schuldbetrag wird nicht verzinst.
Hier ist die überarbeitete und optimierte Version mit der klaren Integration der verantwortlichen Partei, die die Einziehung nach einem Widerruf übernimmt:


2. SEPA-Lastschriftmandat und Einziehungsregelung
Der Schuldner erteilt dem Gläubiger das Mandat, die monatlichen Raten in Höhe von ______________ € jeweils am ___. Tag eines Monats, erstmals am ___. ______________ _____, mittels SEPA-Lastschrift von folgendem Konto einzuziehen:

    Kontoinhaber: ________________________
    IBAN: ________________________
    BIC: ________________________
    Kreditinstitut: ________________________

Die Einziehung der Beträge wird an [Name der Kanzlei/Inkassofirma/Plattform] übertragen, die im Auftrag des Gläubigers handelt. Der Schuldner stimmt der Übermittlung der für die Einziehung notwendigen persönlichen Daten und Vertragsdetails zu.

Das SEPA-Lastschriftmandat gilt für die gesamte Laufzeit des Schuldanerkenntnisses. Der Schuldner verpflichtet sich, für ausreichende Deckung auf dem Konto zu sorgen. Der Gläubiger informiert den Schuldner mindestens 1 Werktag vor der Abbuchung über Betrag und Termin (Pre-Notification).

Im Falle eines Widerrufs des SEPA-Lastschriftmandats wird die Einziehung der fälligen Beträge an [Name der Kanzlei/Inkassofirma/Plattform] übertragen, die berechtigt ist, alle zur Eintreibung erforderlichen Maßnahmen durchzuführen. Der Schuldner bleibt in diesem Fall verpflichtet, die Raten fristgerecht auf andere Weise zu leisten, wie sie von [Name der Kanzlei/Inkassofirma/Plattform] oder dem Gläubiger vorgegeben werden.


3. Der Schuldner ist berechtigt, jederzeit den noch ausstehenden Schuldbetrag vollständig oder teilweise vorzeitig zu tilgen, ohne dass der Schuldner durch die vorzeitige Tilgung zur Zahlung einer Entschädigung verpflichtet wird.


4. Rechtzeitigkeit der Zahlungen
Für die Rechtzeitigkeit der Zahlungen gilt Folgendes:

- Im Fall von Zahlungen per SEPA-Lastschrift ist der Zeitpunkt der erfolgreichen Abbuchung vom Konto des Schuldners maßgeblich.
- Bei allen anderen Zahlungsmethoden ist der Eingang des fälligen Betrags auf dem Konto des Gläubigers oder der beauftragten Kanzlei/Inkassofirma maßgeblich.
- Der Schuldner ist verpflichtet, sicherzustellen, dass der Zahlungsbetrag am Fälligkeitstag vollständig verfügbar ist.


5. Gerät der Schuldner mit der Zahlung ganz oder teilweise in Verzug, ist der fällige Schuldbetrag für die Zeit des Verzugs mit einem Verzugszinssatz von 1 Prozent pro
Jahr zu verzinsen (nachfolgend der „Verzugszinssatz“), ohne dass es einer Mahnung
bedarf.


6. Dem Schuldner bleibt der Nachweis unbenommen, dass dem Gläubiger ein geringerer
Schaden entstanden ist. Der Schuldner ist jedoch zumindest zur Zahlung der
gesetzlichen Verzugszinsen gemäß § 288 BGB verpflichtet.

//hier noch, dass der schuldner alles außer verzugszinsen ausnimmt oder so

7. Der Schuldner ist darüber hinaus zum Ersatz aller dem Gläubiger aufgrund des
Zahlungsverzugs entstandenen Schäden, einschließlich aber nicht beschränkt auf die
zur Durchsetzung seiner Rechte aus diesem Schuldanerkenntnis erforderlichen
Rechtsverfolgungskosten, verpflichtet.


8. Gerät der Schuldner mit der Zahlung von mindestens zwei aufeinanderfolgenden Raten
oder mit der Zahlung eines Betrags, der seiner Höhe nach mindestens zwei Raten
entspricht, in Verzug, ist der Gläubiger des Weiteren berechtigt, den ausstehenden
Schuldbetrag mit sofortiger Wirkung fällig zu stellen. Der fällig gestellte Schuldbetrag ist
in diesem Fall ab seiner Fälligkeit bis zur Zahlung an den Gläubiger mit dem
vorgenannten Verzugszinssatz zu verzinsen.


9. Der Gläubiger ist berechtigt, die Forderung aus diesem Schuldanerkenntnis an Dritte
abzutreten und dabei die für die Forderung relevanten persönlichen Daten des
Schuldners an diese Dritte weiterzugeben.


10. Der Gläubiger ermächtigt Germania Inkasso-Dienst GmbH & Co. KG, die Forderung aus
diesem Schuldschein im Falle der Nichtzahlung einzuziehen und alle damit
verbundenen rechtlichen Schritte einzuleiten.

11. Dieses Schuldanerkenntnis unterliegt ausschließlich materiellem Sachrecht der
Bundesrepublik Deutschland. Die Anwendung der Regeln des internationalen
Privatrechts ist ausgeschlossen, soweit sie zu einer Anwendung ausländischen
Sachrechts führen würde.

12. Änderungen und Ergänzungen dieses Schuldanerkenntnisses bedürfen zu ihrer
Wirksamkeit der Schriftform. Dies gilt auch für die Aufhebung dieses
Schriftformerfordernisses.

13. Sollten einzelne Bestimmungen dieses Schuldanerkenntnisses unwirksam oder
undurchführbar sein oder nach Vertragsschluss unwirksam oder undurchführbar
werden, bleibt davon die Wirksamkeit des Schuldanerkenntnisses im Übrigen unberührt.
Anstelle der unwirksamen oder undurchführbaren Bestimmung soll diejenige wirksame
und durchführbare Regelung treten, deren Wirkungen dem von den Vertragsparteien mit
der unwirksamen bzw. undurchführbaren Bestimmung verfolgten wirtschaftlichen Zweck
am nächsten kommen. Die vorstehenden Bestimmungen gelten entsprechend für den
Fall, dass sich das Schuldanerkenntnis als lückenhaft erweist.

14. Die in diesem Schuldanerkenntnis getroffenen Regelungen sind abschließend.
Mündliche oder schriftliche Nebenabreden wurden nicht getroffen.
```



## 1.3

```
SCHULDANERKENNTNIS
UND RATENZAHLUNGSVEREINBARUNG

zwischen
________________________________________________ ________________________________________________
- nachfolgend „Schuldner“ genannt -

und
________________________________________________ ________________________________________________
 - nachfolgend „Gläubiger“ genannt -


1. Hiermit erkennt der Schuldner zur selbstständigen Begründung der Zahlungsverpflichtung und unter Ausschluss jeglicher bekannter oder für möglich erachteter Einwendungen gegen die durch diesen Vertrag begründete Forderung an, dass er dem Gläubiger einen Betrag in Höhe von ________________ € (nachfolgend der „Schuldbetrag“) schuldet. Diser setzt sich aus dem ursprünglich ?geschuldetem? Betrag sowie einer vereinbarten Gebührt von ____ (____% des ursprünglich geschuldetem Betrages) zusammen. Der Schuldbetrag wird nicht verzinst.
   
   
2. Der Schuldner ist berechtigt, während der Laufzeit des Schuldanerkenntnisses bis zu dreimal eine monatliche Ratenzahlung aufzuschieben. Der Schuldner hat den Aufschub spätestens 7 Tage vor Fälligkeit der jeweiligen Rate schriftlich beim Gläubiger zu beantragen. Die aufgeschobenen Raten sind spätestens im darauffolgenden Monat zusammen mit der regulär fälligen Rate zu leisten. Während des genehmigten Aufschubs entstehen keine Verzugszinsen. Gerät der Schuldner mit der Zahlung einer aufgeschobenen Rate in Verzug, gelten die allgemeinen Verzugsregelungen dieses Vertrags.


3. SEPA-Lastschriftmandat und Einziehungsregelung
Der Schuldner erteilt dem Gläubiger das Mandat, die monatlichen Raten in Höhe von ______________ € jeweils am ___. Tag eines Monats, erstmals am ___. ______________ _____, mittels SEPA-Lastschrift von folgendem Konto einzuziehen:
	Kontoinhaber: ________________________
    IBAN: ________________________
    BIC: ________________________
    Kreditinstitut: ________________________
    Die Einziehung der Beträge wird an [Name der Kanzlei/Inkassofirma/Plattform]übertragen, die im Auftrag des Gläubigers handelt. Der Schuldner stimmt der Übermittlung der für die Einziehung notwendigen persönlichen Daten und Vertragsdetails zu.Das SEPA-Lastschriftmandat gilt für die gesamte Laufzeit des Schuldanerkenntnisses. Der Schuldner verpflichtet sich, für ausreichende Deckung auf dem Konto zu sorgen. Der Gläubiger informiert den Schuldner mindestens 1 Werktag vor der Abbuchung über Betrag und Termin (Pre-Notification).

Im Falle eines Widerrufs des SEPA-Lastschriftmandats wird die Einziehung der fälligen Beträge an ________________ übertragen, die berechtigt ist, alle zur Eintreibung erforderlichen Maßnahmen durchzuführen. Der Schuldner bleibt in diesem Fall verpflichtet, die Raten fristgerecht auf andere Weise zu leisten, wie sie von Owee GmBH ?oder dem Gläubiger vorgegeben werden.?

5. Rechtzeitigkeit der Zahlungen
Für die Rechtzeitigkeit der Zahlungen gilt Folgendes:

- Im Fall von Zahlungen per SEPA-Lastschrift ist der Zeitpunkt der erfolgreichen Abbuchung vom Konto des Schuldners maßgeblich.
- Bei allen anderen Zahlungsmethoden ist der Eingang des fälligen Betrags auf dem Konto des Gläubigers oder der beauftragten Kanzlei/Inkassofirma maßgeblich.
- Der Schuldner ist verpflichtet, sicherzustellen, dass der Zahlungsbetrag am Fälligkeitstag vollständig verfügbar ist.

4. Der Schuldner ist berechtigt, jederzeit den noch ausstehenden Schuldbetrag vollständig oder teilweise vorzeitig zu tilgen, ohne dass der Schuldner durch die vorzeitige Tilgung zur Zahlung einer Entschädigung verpflichtet wird.

6. Gerät der Schuldner mit der Zahlung ganz oder teilweise in Verzug, ist der fällige Schuldbetrag für die Zeit des Verzugs mit einem Verzugszinssatz von 1 Prozent pro Jahr zu verzinsen (nachfolgend der „Verzugszinssatz“), ohne dass es einer Mahnung bedarf.

?
7. Gerät der Schuldner mit der Zahlung von mindestens zwei aufeinanderfolgenden Raten oder mit der Zahlung eines Betrags, der seiner Höhe nach mindestens zwei Raten entspricht, in Verzug, ist der Gläubiger des Weiteren berechtigt, den ausstehenden Schuldbetrag mit sofortiger Wirkung fällig zu stellen. Der fällig gestellte Schuldbetrag ist in diesem Fall ab seiner Fälligkeit bis zur Zahlung an den Gläubiger mit dem vorgenannten Verzugszinssatz zu verzinsen.
?

7. Dem Schuldner bleibt der Nachweis unbenommen, dass dem Gläubiger ein geringerer
Schaden entstanden ist. Der Schuldner ist jedoch zumindest zur Zahlung der
gesetzlichen Verzugszinsen gemäß § 288 BGB verpflichtet.

9. Der Gläubiger ist berechtigt, die Forderung aus diesem Schuldanerkenntnis an Dritte abzutreten und dabei die für die Forderung relevanten persönlichen Daten des
Schuldners an diese Dritte weiterzugeben.

10. Der Gläubiger ermächtigt ____________________________, die Forderung aus
diesem Schuldschein im Falle der Nichtzahlung einzuziehen und alle damit
verbundenen rechtlichen Schritte einzuleiten.

11. Dieses Schuldanerkenntnis unterliegt ausschließlich materiellem Sachrecht der
Bundesrepublik Deutschland. Die Anwendung der Regeln des internationalen
Privatrechts ist ausgeschlossen, soweit sie zu einer Anwendung ausländischen
Sachrechts führen würde.

?
12. Änderungen und Ergänzungen dieses Schuldanerkenntnisses bedürfen zu ihrer
Wirksamkeit der Schriftform. Dies gilt auch für die Aufhebung dieses
Schriftformerfordernisses.?

13. Sollten einzelne Bestimmungen dieses Schuldanerkenntnisses unwirksam oder
undurchführbar sein oder nach Vertragsschluss unwirksam oder undurchführbar
werden, bleibt davon die Wirksamkeit des Schuldanerkenntnisses im Übrigen unberührt.
Anstelle der unwirksamen oder undurchführbaren Bestimmung soll diejenige wirksame
und durchführbare Regelung treten, deren Wirkungen dem von den Vertragsparteien mit
der unwirksamen bzw. undurchführbaren Bestimmung verfolgten wirtschaftlichen Zweck
am nächsten kommen. Die vorstehenden Bestimmungen gelten entsprechend für den
Fall, dass sich das Schuldanerkenntnis als lückenhaft erweist.

14. Die in diesem Schuldanerkenntnis getroffenen Regelungen sind abschließend.
Mündliche oder schriftliche Nebenabreden wurden nicht getroffen.
```


## 1.4 neuformulierung durch chatgpt

```
SCHULDANERKENNTNIS UND RATENZAHLUNGSVEREINBARUNG

zwischen:

Name des Schuldners:_________________________________ Adresse:____________________________________________

- nachfolgend "Schuldner" genannt -
    

und:

Name des Gläubigers: _________________________________ 
Adresse: ____________________________________________

- nachfolgend "Gläubiger" genannt -
    

sowie:

Name der Plattform: _________________________________ 
Adresse: ____________________________________________

- nachfolgend "Plattform" genannt -
    

Präambel: Der Schuldner und der Gläubiger haben eine Forderung vereinbart, deren Modalitäten in diesem Vertrag geregelt werden. Die Plattform agiert als Vermittler und übernimmt die Verwaltung und technische Abwicklung der Zahlungen.

1. Anerkennung der Schuld

1.1 Der Schuldner erkennt an, dass er dem Gläubiger einen Betrag in Höhe von _______________ € (nachfolgend der "Schuldbetrag") schuldet. 1.2 Der Schuldbetrag setzt sich aus dem ursprünglich geschuldeten Betrag in Höhe von _______________ € sowie einer Einigungsvergütung in Höhe von _______________ € (___ % des ursprünglich geschuldeten Betrags) zusammen. 1.3 Der Schuldbetrag wird nicht verzinst.

2. Ratenzahlung und Aufschub

2.1 Der Schuldbetrag wird in monatlichen Raten von _______________ € jeweils am ____. Tag eines Monats, erstmals am ____. _______________ ______, fällig. 2.2 Der Schuldner ist berechtigt, bis zu dreimal eine monatliche Ratenzahlung aufzuschieben. Der Aufschub ist spätestens 7 Tage vor Fälligkeit der jeweiligen Rate schriftlich bei der Plattform zu beantragen. 2.3 Aufgeschobene Raten sind spätestens im darauffolgenden Monat zusammen mit der regulären Rate zu zahlen. Während des genehmigten Aufschubs fallen keine Verzugszinsen an. 2.4 Gerät der Schuldner mit einer aufgeschobenen Rate in Verzug, gelten die allgemeinen Verzugsregelungen dieses Vertrags.

3. SEPA-Lastschriftmandat und Einziehungsregelung

3.1 Der Schuldner erteilt hiermit ein SEPA-Lastschriftmandat zur Einziehung der monatlichen Raten von folgendem Konto:

- Kontoinhaber: ________________________________
    
- IBAN: _______________________________________
    
- BIC: _______________________________________
    
- Kreditinstitut: _______________________________
    

3.2 Die Einziehung der Beträge wird von der Plattform oder einem von ihr beauftragten Finanzdienstleister im Namen des Gläubigers durchgeführt. 

3.3 Der Schuldner verpflichtet sich, für ausreichende Deckung auf dem Konto zu sorgen. Die Plattform informiert den Schuldner mindestens 1 Werktag vor der Abbuchung (Pre-Notification). 3.4 Im Falle eines Widerrufs des SEPA-Lastschriftmandats bleibt der Schuldner verpflichtet, die Raten auf alternative Weise fristgerecht zu zahlen. Als alternative Zahlungsmöglichkeit wird folgende Bankverbindung angegeben:

- Kontoinhaber: ________________________________
    
- IBAN: _______________________________________
    
- BIC: _______________________________________
    
- Kreditinstitut: _______________________________
    

4. Vorzeitige Tilgung

4.1 Der Schuldner ist berechtigt, den noch ausstehenden Schuldbetrag jederzeit vollständig oder teilweise vorzeitig zu tilgen. 4.2 Für eine vorzeitige Tilgung fallen keine zusätzlichen Entschädigungen an.

5. Rechtzeitigkeit der Zahlungen

5.1 Im Fall von Zahlungen per SEPA-Lastschrift ist der Zeitpunkt der erfolgreichen Abbuchung vom Konto des Schuldners maßgeblich. 
5.2 Bei anderen Zahlungsmethoden ist der Eingang des fälligen Betrags auf dem Konto des Gläubigers oder der Plattform entscheidend. 
5.3 Der Schuldner ist verpflichtet, sicherzustellen, dass der Zahlungsbetrag am Fälligkeitstag verfügbar ist.

6. Verzugszinsen

6.1 Gerät der Schuldner in Verzug, wird der Schuldbetrag ab dem Fälligkeitsdatum mit einem Verzugszinssatz von 1 % pro Jahr verzinst. 

6.2 Eine Mahnung ist für den Verzug nicht erforderlich.


7. Fälligkeit des Gesamtbetrags bei Verzug

7.1 Gerät der Schuldner mit der Zahlung von mindestens zwei aufeinanderfolgenden Raten oder einem Betrag in Höhe von mindestens zwei Raten in Verzug, ist der Gläubiger berechtigt, den gesamten Schuldbetrag sofort fällig zu stellen. 
7.2 Der sofort fällig gestellte Betrag wird ab dem Fälligkeitsdatum bis zur Zahlung verzinst.

8. Nachweis eines geringeren Schadens

8.1 Der Schuldner kann nachweisen, dass dem Gläubiger durch den Verzug ein geringerer Schaden entstanden ist. 8.2 Der Schuldner bleibt jedoch mindestens zur Zahlung der gesetzlichen Verzugszinsen gemäß § 288 BGB verpflichtet.

9. Abtretung der Forderung

9.1 Der Gläubiger ist berechtigt, die Forderung an Dritte abzutreten. 

9.2 Der Schuldner stimmt zu, dass personenbezogene Daten im Rahmen der Abtretung gemäß den gesetzlichen Datenschutzbestimmungen weitergegeben werden.


10. Beauftragung Dritter

10.1 Der Gläubiger ermächtigt die Plattform oder ein beauftragtes Inkassounternehmen, die Forderung im Falle der Nichtzahlung einzuziehen und rechtliche Schritte einzuleiten.

11. Anwendbares Recht

11.1 Dieser Vertrag unterliegt ausschließlich deutschem Recht. Die Anwendung des internationalen Privatrechts ist ausgeschlossen, soweit es zur Anwendung ausländischen Rechts führen würde.

12. Schriftformerfordernis

12.1 Änderungen und Ergänzungen dieses Vertrags bedürfen der Schriftform. Dies gilt auch für die Aufhebung des Schriftformerfordernisses.

13. Salvatorische Klausel

13.1 Sollte eine Bestimmung dieses Vertrags unwirksam sein, bleibt die Wirksamkeit der übrigen Bestimmungen unberührt. Anstelle der unwirksamen Bestimmung tritt eine rechtlich zulässige Regelung, die dem wirtschaftlichen Zweck der unwirksamen Regelung am nächsten kommt.

14. Vollständigkeit

14.1 Dieser Vertrag enthält alle Vereinbarungen zwischen den Parteien. Es gibt keine mündlichen oder schriftlichen Nebenabreden.

Ort, Datum: _______________________________
Unterschrift Schuldner: _______________________________
Unterschrift Gläubiger: _______________________________
Unterschrift Plattform (falls erforderlich): _______________________________
```


## 1.5

```
SCHULDANERKENNTNIS UND RATENZAHLUNGSVEREINBARUNG

zwischen

Schuldner-ID: ______________________________

- nachfolgend „Schuldner“ genannt -
    

und

Gläubiger-ID: ______________________________

- nachfolgend „Gläubiger“ genannt -
    

1. Anerkennung der Schuld
    

Hiermit erkennt der Schuldner, identifiziert durch die Schuldner-ID, zur selbstständigen Begründung der Zahlungsverpflichtung und unter Ausschluss jeglicher ihm zum Zeitpunkt des Vertragsschlusses bekannter Einwendungen gegen die durch diesen Vertrag begründete Forderung an, dass er dem Gläubiger, identifiziert durch die Gläubiger-ID, einen Betrag in Höhe von ________________ € (nachfolgend der „Schuldbetrag“) schuldet. Dieser setzt sich aus dem ursprünglich geschuldeten Betrag sowie einer einmaligen Einigungsvergütung in Höhe von ____________ € (____% des ursprünglich geschuldeten Betrages) zusammen. Der Schuldbetrag wird nicht verzinst.

2. SEPA-Lastschriftmandat und Einziehungsregelung
    

Der Schuldner, identifiziert durch die Schuldner-ID, erteilt dem Gläubiger, identifiziert durch die Gläubiger-ID, das Mandat, die monatlichen Raten in Höhe von ______________ € jeweils am ___. Tag eines Monats, erstmals am ___. ______________ _____, mittels SEPA-Lastschrift von folgendem Konto einzuziehen:

Kontoinhaber (Schuldner-ID): ________________________  
IBAN: ________________________  
BIC: ________________________  
Kreditinstitut: ________________________

Die Einziehung der Beträge wird an [Name der Kanzlei/Inkassofirma/Plattform] übertragen, die im Auftrag des Gläubigers handelt. Der Schuldner stimmt der Übermittlung der für die Einziehung notwendigen Vertragsdetails zu.

Das SEPA-Lastschriftmandat gilt für die gesamte Laufzeit des Schuldanerkenntnisses. Der Schuldner verpflichtet sich, für ausreichende Deckung auf dem Konto zu sorgen. Der Gläubiger informiert den Schuldner mindestens 1 Werktag vor der Abbuchung über Betrag und Termin (Pre-Notification).

Im Falle eines Widerrufs des SEPA-Lastschriftmandats wird die Einziehung der fälligen Beträge an [Name der Kanzlei/Inkassofirma/Plattform] übertragen, die berechtigt ist, alle zur Eintreibung erforderlichen Maßnahmen durchzuführen. Der Schuldner bleibt in diesem Fall verpflichtet, die Raten fristgerecht auf andere Weise zu leisten, wie sie von [Name der Kanzlei/Inkassofirma/Plattform] oder dem Gläubiger vorgegeben werden. Der Schuldner wird rechtzeitig über die neue Zahlungsweise informiert.

3. Vorzeitige Tilgung
    

Der Schuldner ist berechtigt, jederzeit den noch ausstehenden Schuldbetrag vollständig oder teilweise vorzeitig zu tilgen, ohne dass der Schuldner durch die vorzeitige Tilgung zur Zahlung einer Entschädigung verpflichtet wird.

4. Rechtzeitigkeit der Zahlungen
    

Für die Rechtzeitigkeit der Zahlungen gilt Folgendes:  
SEPA-Lastschrift: Der Zeitpunkt der erfolgreichen Abbuchung vom Konto des Schuldners ist maßgeblich.  
Andere Zahlungsmethoden: Der Eingang des fälligen Betrags auf dem Konto des Gläubigers oder der beauftragten Kanzlei/Inkassofirma ist maßgeblich.  
Der Schuldner ist verpflichtet, sicherzustellen, dass der Zahlungsbetrag am Fälligkeitstag vollständig verfügbar ist.

5. Verzugszinsen
    

Gerät der Schuldner mit der Zahlung ganz oder teilweise in Verzug, ist der Schuldbetrag für die Zeit des Verzugs mit einem Verzugszinssatz von mindestens 1 % pro Jahr oder, sofern höher, den gesetzlichen Verzugszinsen gemäß § 288 BGB zu verzinsen, ohne dass es einer Mahnung bedarf.

6. Nachweis eines geringeren Schadens
    

Dem Schuldner bleibt der Nachweis unbenommen, dass dem Gläubiger ein geringerer Schaden entstanden ist. Der Schuldner ist jedoch mindestens zur Zahlung der gesetzlichen Verzugszinsen gemäß § 288 BGB verpflichtet.

7. Ersatz von Verzugsschäden
    

Der Schuldner ist verpflichtet, dem Gläubiger alle nachweislich entstandenen und vorhersehbaren Schäden zu ersetzen, die aus dem Zahlungsverzug resultieren, einschließlich aber nicht beschränkt auf die zur Durchsetzung seiner Rechte aus diesem Schuldanerkenntnis erforderlichen Rechtsverfolgungskosten.

8. Fälligkeit des Gesamtbetrags bei schwerwiegendem Verzug
    

Gerät der Schuldner mit der Zahlung von mindestens zwei aufeinanderfolgenden Raten oder mit der Zahlung eines Betrags, der seiner Höhe nach mindestens zwei Raten entspricht, in Verzug, ist der Gläubiger berechtigt, den ausstehenden Schuldbetrag mit sofortiger Wirkung fällig zu stellen. Der fällig gestellte Schuldbetrag ist in diesem Fall ab seiner Fälligkeit bis zur Zahlung an den Gläubiger mit dem vorgenannten Verzugszinssatz zu verzinsen.

9. Abtretung der Forderung
    

Der Gläubiger ist berechtigt, die Forderung aus diesem Schuldanerkenntnis an Dritte abzutreten. Der Schuldner wird unverzüglich über die Abtretung und die Kontaktdaten des neuen Gläubigers informiert. Dabei dürfen die relevanten Daten des Schuldners nur im erforderlichen Umfang weitergegeben werden.

10. Zuständigkeit von Dritten
    

Der Gläubiger ermächtigt [Name der Kanzlei/Inkassofirma/Plattform], die Forderung im Falle der Nichtzahlung einzuziehen und alle damit verbundenen rechtlichen Schritte einzuleiten.

11. Anwendbares Recht
    

Dieses Schuldanerkenntnis unterliegt ausschließlich dem Recht der Bundesrepublik Deutschland. Die Anwendung der Regeln des internationalen Privatrechts ist ausgeschlossen, soweit sie zu einer Anwendung ausländischen Rechts führen würde.

12. Einvernehmliche Änderungen über die Plattform
    

Änderungen und Ergänzungen dieses Vertrags sind ausschließlich einvernehmlich und über die Plattform [Name der Plattform] möglich. Beide Parteien erklären sich damit einverstanden, dass Änderungen durch Nutzung der dafür vorgesehenen Funktionen der Plattform erfolgen und als verbindlich gelten. Jede Änderung wird auf der Plattform dokumentiert und den Vertragsparteien zugänglich gemacht. Die Plattform speichert alle Änderungen mit Zeitstempel und Identitätsnachweis, um deren Nachvollziehbarkeit zu gewährleisten. Sollte die Plattform vorübergehend oder dauerhaft nicht verfügbar sein, sind Änderungen schriftlich oder in Textform zwischen den Parteien zu vereinbaren.

13. Salvatorische Klausel
    

Sollten einzelne Bestimmungen dieses Schuldanerkenntnisses unwirksam oder undurchführbar sein oder nach Vertragsschluss unwirksam oder undurchführbar werden, bleibt davon die Wirksamkeit des Schuldanerkenntnisses im Übrigen unberührt. Anstelle der unwirksamen oder undurchführbaren Bestimmung soll diejenige wirksame und durchführbare Regelung treten, deren Wirkungen dem von den Vertragsparteien mit der unwirksamen bzw. undurchführbaren Bestimmung verfolgten wirtschaftlichen Zweck am nächsten kommen. Die vorstehenden Bestimmungen gelten entsprechend für den Fall, dass sich das Schuldanerkenntnis als lückenhaft erweist.

14. Offenlegung personenbezogener Daten im Streitfall**

(1) Die Parteien vereinbaren, dass die hinter den in diesem Vertrag verwendeten ID-Nummern gespeicherten personenbezogenen Daten (z. B. Name, Anschrift, Kontaktdaten) ausschließlich zu den in diesem Vertrag festgelegten Zwecken verarbeitet werden.​

(2) Im Falle eines Rechtsstreits oder eines behördlichen Verfahrens, in dem die Identität einer Partei zur Durchsetzung oder Verteidigung von Rechten erforderlich ist, dürfen die entsprechenden personenbezogenen Daten offengelegt werden, sofern und soweit dies zur Wahrung berechtigter Interessen gemäß Art. 6 Abs. 1 lit. f DSGVO erforderlich ist.​

(3) Die Offenlegung erfolgt ausschließlich gegenüber den zuständigen Gerichten, Behörden oder anderen an dem Verfahren beteiligten Parteien und nur in dem Umfang, der zur Erfüllung des jeweiligen Zwecks notwendig ist.​

(4) Die Partei, die die Offenlegung vornimmt, informiert die betroffene Person unverzüglich über die erfolgte Datenweitergabe, sofern nicht gesetzliche Vorschriften oder gerichtliche Anordnungen dem entgegenstehen.​

(5) Die Parteien verpflichten sich, alle angemessenen technischen und organisatorischen Maßnahmen zu ergreifen, um die Sicherheit und Vertraulichkeit der offengelegten personenbezogenen Daten gemäß Art. 32 DSGVO zu gewährleisten.​

15. Abschließende Regelungen
    

Die in diesem Schuldanerkenntnis getroffenen Regelungen sind abschließend. Mündliche oder schriftliche Nebenabreden wurden nicht getroffen.
```


wie mache ich auf element reagieren möglich:
1. user clicks element > create_chat.php is called and returns chat_id and receiver id and profileURL (first profile picture of receiver) and with that data > chat popup(element data, receiver_id, profile_url) is opened with the element_reacted_to shown above inputfield and user can type comment and send first bubble into the chat. User could also send a second message if wanted. 

create_chat.php schaut nach, ob es schon einen chat zwischen den beiden gibt und wenn 
ja : returnt den chat
nein: erstell den chat & vermerkt ein match sowie swipe.php wenn swipe nach rechts. 

1. make chatpopup call the new 
2. schreibe cardstack.dart entsprechend um
3. schreibe create_chat.php







wie mache ich auf Element reagieren möglich:
1. user clicks element > chat popup(element data, receiver_id) is opened with the element_reacted_to shown above inputfield and user can type comment and click send > sendReaction.php is called and which does the same as swipe.php on swipe right (saving as right swipe in matches db) & also creates a new chat with the two participants and returns if its a match or not and if yes, also the chat data.

Here as reference of how to do the things in 

sendReaction.php schaut nach, ob es schon einen chat zwischen den beiden gibt und wenn 
ja : returnt den chat
nein: erstell den chat & vermerkt ein match sowie swipe.php wenn swipe nach rechts. 

1. make chatpopup call the new sendReaction.php when sending a message
2. schreibe cardstack.dart entsprechend um
3. schreibe sendReaction.php

sendReaction.php:
- gets called as POST with jwt as auth bearer, and in payload:
	- react_to
		- type: 
		- content:
	- comment:
	- receiver_id:

- gets id from jwt

- looks up if chat with these two participants already exists
	- yes > save the comment as newest message in the chat
	- no > create it

- looks up if its a match
	- yes > return that its a match and the chat (same way as swipe.php would)
	- no > return that its no match (same way as swipe.php would)

chatpopup.dart
- shows element
- shows inputfield
- when comment is sent, calls the sendReaction.php with jwt from securestorage
	- if its a match > navigate to chat.dart
	- if not > navigate to card_stack.dart where current card should be dismissed and next one shown 

rewrite cardstack so it can be called with some message that it should dismiss the current card when popup was clicked.


"
// chat_popup.dart

import 'package:flutter/material.dart';

import 'package:flutter_secure_storage/flutter_secure_storage.dart';

import 'package:flutter_svg/flutter_svg.dart';

import 'package:http/http.dart' as http;

import 'dart:convert';

  

import 'package:swipe_chat_play/colors.dart';

import 'package:swipe_chat_play/fonts.dart';

import 'package:swipe_chat_play/config.dart';

  

class ChatPopupDialog extends StatefulWidget {

  final Map<String, dynamic> reactionPayload;

  const ChatPopupDialog({

    Key? key,

    required this.reactionPayload,

  }) : super(key: key);

  

  @override

  _ChatPopupDialogState createState() => _ChatPopupDialogState();

}

  

class _ChatPopupDialogState extends State<ChatPopupDialog> {

  final storage = const FlutterSecureStorage();

  final TextEditingController _commentController = TextEditingController();

  late FocusNode _focusNode;

  bool _isRecording = false;

  bool _isSending = false;

  

  @override

  void initState() {

    super.initState();

    _focusNode = FocusNode();

    debugPrint(

        "[ChatPopupDialog] initState => reactionPayload: ${widget.reactionPayload}");

  }

  

  @override

  void dispose() {

    _commentController.dispose();

    _focusNode.dispose();

    super.dispose();

  }

  

  @override

  Widget build(BuildContext context) {

    final reactionType = widget.reactionPayload['type'] ?? 'react_unknown';

    final content = widget.reactionPayload['content'] ?? {};

    debugPrint(

        "[ChatPopupDialog] build => reactionType=$reactionType, content=$content");

  

    return Dialog(

      elevation: 0,

      backgroundColor: Colors.white,

      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),

      insetPadding: const EdgeInsets.symmetric(horizontal: 10, vertical: 40),

      child: SizedBox(

        width: double.infinity,

        height: 360,

        child: Column(

          mainAxisSize: MainAxisSize.min,

          children: [

            // Close button.

            Row(

              mainAxisAlignment: MainAxisAlignment.end,

              children: [

                IconButton(

                  icon: const Icon(Icons.close, color: Colors.grey),

                  onPressed: () {

                    debugPrint("[ChatPopupDialog] User closed popup manually");

                    Navigator.of(context).pop();

                  },

                )

              ],

            ),

            // Pinned element.

            _buildPinnedElement(reactionType, content),

            const Divider(thickness: 1, height: 1, color: Colors.grey),

            // Input field.

            _buildCommentInput(),

          ],

        ),

      ),

    );

  }

  

  /// Build a Chip styled like the bubbles.

  Widget _buildBubbleChip(String text) {

    return Chip(

      label: Text(

        text.trim(),

        style: AppFonts.tertiaryFont.copyWith(

          fontSize: 14,

          fontWeight: FontWeight.w600,

          color: AppColors.text,

        ),

      ),

      backgroundColor: const Color(0xFFF5F5F5),

      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 8),

      shape: RoundedRectangleBorder(

        borderRadius: BorderRadius.circular(100),

        side: const BorderSide(color: Colors.transparent, width: 0),

      ),

    );

  }

  

  /// Build the pinned element based on reaction type.

  Widget _buildPinnedElement(

      String reactionType, Map<String, dynamic> content) {

    switch (reactionType) {

      case 'react_bubble':

      case 'react_top_section_bubble':

        final bubbleText =

            content['bubble_label'] ?? content['bubble_text'] ?? 'Unknown';

        debugPrint(

            "[ChatPopupDialog] Building pinned bubble with text: $bubbleText");

        return Padding(

          padding: const EdgeInsets.only(bottom: 10),

          child: _buildBubbleChip(bubbleText),

        );

      case 'react_icebreaker':

        final question = content['question'] ?? 'No question';

        final answer = content['answer'] ?? 'No answer';

        debugPrint(

            "[ChatPopupDialog] Building pinned icebreaker Q=$question, A=$answer");

        return Container(

          width: double.infinity,

          alignment: Alignment.topLeft,

          padding: const EdgeInsets.fromLTRB(25, 25, 25, 25),

          child: Column(

            crossAxisAlignment: CrossAxisAlignment.start,

            children: [

              const SizedBox(height: 20),

              Text(

                question,

                style: AppFonts.secondaryFont.copyWith(

                  fontSize: 16,

                  fontWeight: FontWeight.w400,

                  color: AppColors.text,

                ),

              ),

              const SizedBox(height: 5),

              Text(

                answer,

                style: AppFonts.tertiaryFont.copyWith(

                  fontSize: 22,

                  fontWeight: FontWeight.w400,

                  color: AppColors.text,

                ),

              ),

              const SizedBox(height: 20),

            ],

          ),

        );

      case 'react_profile_image':

        final url = content['image_url'] ?? '';

        debugPrint("[ChatPopupDialog] Building pinned profile image: $url");

        return Padding(

          padding: const EdgeInsets.only(bottom: 10),

          child: Column(

            children: [

              Text("Reacting to image:", style: AppFonts.primaryFont),

              const SizedBox(height: 5),

              ClipRRect(

                borderRadius: BorderRadius.circular(8),

                child: Image.network(

                  url,

                  width: 120,

                  height: 120,

                  fit: BoxFit.cover,

                ),

              ),

            ],

          ),

        );

      default:

        debugPrint(

            "[ChatPopupDialog] reactionType=$reactionType => fallback pinned element");

        return const SizedBox.shrink();

    }

  }

  

  /// Build the input field with styling matching your chat.dart.

  Widget _buildCommentInput() {

    return Container(

      decoration: BoxDecoration(

        color: Colors.white,

        boxShadow: const [

          BoxShadow(

            color: Colors.black12,

            offset: Offset(0, -2),

            blurRadius: 4,

          ),

        ],

      ),

      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 8),

      child: Row(

        children: [

          Expanded(

            child: TextField(

              controller: _commentController,

              focusNode: _focusNode,

              cursorColor: Colors.pinkAccent,

              style: const TextStyle(color: Colors.black87),

              decoration: const InputDecoration(

                hintText: "Add a comment...",

                hintStyle: TextStyle(color: Colors.grey),

                border: InputBorder.none,

                contentPadding: EdgeInsets.only(left: 8),

              ),

            ),

          ),

          GestureDetector(

            onTapDown: (details) {

              debugPrint(

                  "[ChatPopupDialog] onTapDown => potential start of recording");

            },

            onTapUp: (details) async {

              final text = _commentController.text.trim();

              if (text.isNotEmpty) {

                debugPrint(

                    "[ChatPopupDialog] onTapUp => sending reaction with comment=$text");

                await _sendReactionMessage();

              } else {

                debugPrint(

                    "[ChatPopupDialog] onTapUp => empty comment, ignoring");

              }

            },

            child: Container(

              width: _isRecording ? 60 : 40,

              height: _isRecording ? 60 : 40,

              decoration: BoxDecoration(

                shape: BoxShape.circle,

                gradient: _isRecording

                    ? const LinearGradient(

                        colors: [Colors.red, Colors.orange],

                        begin: Alignment.topLeft,

                        end: Alignment.bottomRight,

                      )

                    : const LinearGradient(

                        colors: [Colors.pinkAccent, Colors.orangeAccent],

                        begin: Alignment.topLeft,

                        end: Alignment.bottomRight,

                      ),

              ),

              child: Icon(

                _commentController.text.trim().isNotEmpty

                    ? Icons.send

                    : (_isRecording ? Icons.mic : Icons.mic_none),

                color: Colors.white,

              ),

            ),

          ),

        ],

      ),

    );

  }

  

  /// Sends the reaction message by calling react_profile.php.

  Future<void> _sendReactionMessage() async {

    final comment = _commentController.text.trim();

    if (comment.isEmpty) {

      debugPrint(

          "[ChatPopupDialog] _sendReactionMessage => empty comment => abort");

      return;

    }

  

    setState(() => _isSending = true);

    final token = await storage.read(key: 'jwt_token');

    if (token == null) {

      debugPrint("[ChatPopupDialog] No token found => can't send reaction");

      setState(() => _isSending = false);

      return;

    }

  

    // Build final request – the payload must already include "profile_username".

    final updatedPayload = Map<String, dynamic>.from(widget.reactionPayload);

    final profileUsername = updatedPayload["profile_username"];

    if (profileUsername == null) {

      debugPrint(

          "[ChatPopupDialog] Missing 'profile_username' in reactionPayload => cannot proceed");

      setState(() => _isSending = false);

      return;

    }

    updatedPayload['content']['comment'] = comment;

  

    final requestBody = {

      "profile_username": profileUsername,

      "type": updatedPayload['type'],

      "timestamp": updatedPayload['timestamp'],

      "content": updatedPayload['content'],

    };

  

    // Print the JSON payload in a formatted manner.

    final prettyRequestJson =

        const JsonEncoder.withIndent('  ').convert(requestBody);

    debugPrint(

        "[ChatPopupDialog] Sending request to react_profile.php:\n$prettyRequestJson");

  

    try {

      final url = Uri.parse(

          "${Config.backendBaseUrl}/match_algorithm/react_profile.php");

      final response = await http.post(

        url,

        headers: {

          "Authorization": "Bearer $token",

          "Content-Type": "application/json"

        },

        body: jsonEncode(requestBody),

      );

  

      debugPrint("[ChatPopupDialog] Response code: ${response.statusCode}");

      debugPrint("[ChatPopupDialog] Response body: ${response.body}");

    } catch (e, st) {

      debugPrint(

          "[ChatPopupDialog] Exception caught while sending reaction: $e");

      debugPrint("$st");

    }

  

    setState(() => _isSending = false);

  }

}
"

"
import 'dart:async';

import 'dart:convert';

import 'dart:math' as math;

  

import 'package:swipe_chat_play/tabs/chat/layouts/chat.dart';

import 'package:flutter/material.dart';

import 'package:flutter_secure_storage/flutter_secure_storage.dart';

import 'package:http/http.dart' as http;

  

import 'package:swipe_chat_play/colors.dart';

import 'package:swipe_chat_play/config.dart';

import 'package:swipe_chat_play/fonts.dart';

  

// We use the NEW profile_data.dart from version 3:

import 'package:swipe_chat_play/profile_layout/models/profile_data.dart'

    as profile;

import 'package:swipe_chat_play/tabs/chat/layouts/chat.dart';

  

// Chat popup or chat page references:

import 'package:swipe_chat_play/tabs/chat/layouts/chat_popup.dart';

  

// IMPORTANT: from version 2, we rely on usage of `profile_layout.dart`

// which exports a "ProfileCard" widget that supports onElementTap:

import 'package:swipe_chat_play/tabs/profile/layouts/profile_layout.dart'

    show ProfileCard;

  

/// This merges scroll & swipe from version 1, reaction chat usage from version 2,

/// and the new user_id logic from version 3.

class CardStack extends StatefulWidget {

  const CardStack({Key? key}) : super(key: key);

  

  @override

  _CardStackState createState() => _CardStackState();

}

  

class _CardStackState extends State<CardStack> {

  List<profile.ProfileData> cardData = [];

  

  bool isLoading = true;

  bool isFetchingMore = false;

  bool hasMore = true;

  int currentPage = 1;

  

  final Debouncer _debouncer = Debouncer(milliseconds: 500);

  

  // Show at most 2 cards at once (back + top).

  final int maxVisibleCards = 2;

  final int prefetchThreshold = 2;

  

  // Tracks the drag offset of the top card (for X & partial Y movement).

  final ValueNotifier<Offset> _dragPositionNotifier =

      ValueNotifier<Offset>(Offset.zero);

  

  // Controller for the top card’s vertical scrolling.

  ScrollController _topCardScrollController = ScrollController();

  

  // --- Swipe thresholds ---

  /// We consider a swipe “done” if the user’s final dx goes beyond this.

  double get swipeThreshold => MediaQuery.of(context).size.width * 0.07;

  

  /// We only switch direction if user crosses 2% beyond the furthest point.

  double get directionChangeThreshold =>

      MediaQuery.of(context).size.width * 0.02;

  

  // --- Gesture detection fields ---

  Offset? _gestureStart;

  bool _isHorizontalSwipe =

      false; // Are we in horizontal-swipe mode vs. vertical scroll?

  bool _decisionMade = false; // Has the angle-based decision been made?

  final double _slopDistance =

      10; // Movement threshold before deciding H vs. V.

  

  /// Tracks the **current** direction we have determined: "left", "right", or null if not set.

  String? _currentDirection;

  

  /// The furthest we’ve gone to the **right** so far (>= 0).

  double _furthestRightSoFar = 0.0;

  

  /// The furthest we’ve gone to the **left** so far (<= 0).

  double _furthestLeftSoFar = 0.0;

  

  @override

  void initState() {

    super.initState();

    _fetchProfiles(reset: true);

  }

  

  Future<void> _fetchProfiles({bool reset = false}) async {

    if (isFetchingMore || (reset == false && !hasMore)) return;

  

    setState(() => reset ? isLoading = true : isFetchingMore = true);

  

    const storage = FlutterSecureStorage();

    final token = await storage.read(key: 'jwt_token');

    if (token == null) {

      setState(() => isLoading = false);

      return;

    }

  

    // As in version 1 & 2, we fetch from match.php.

    // Now it uses user_id in the returned data (version 3 approach).

    final int limit = reset ? 50 : 10;

    try {

      final response = await http.get(

        Uri.parse(

            '${Config.backendBaseUrl}/match_algorithm/match.php?page=$currentPage&limit=$limit'),

        headers: {"Authorization": "Bearer $token"},

      );

  

      if (response.statusCode == 200) {

        final data = jsonDecode(response.body);

        if (data["status"] == "success") {

          final profilesList = (data["data"] as List<dynamic>)

              .map((json) => profile.ProfileData.fromJson(json))

              .toList();

  

          setState(() {

            if (reset) {

              cardData = profilesList;

              currentPage = 1;

            } else {

              cardData.addAll(profilesList);

            }

            hasMore = data["has_more"] ?? false;

            currentPage++;

          });

        }

      }

    } catch (e) {

      debugPrint("Error fetching profiles: $e");

    } finally {

      setState(() => reset ? isLoading = false : isFetchingMore = false);

    }

  }

  

  List<profile.ProfileData> get visibleCards =>

      cardData.reversed.take(maxVisibleCards).toList().reversed.toList();

  

  void _dismissCard(String swipeValue) {

    if (cardData.isEmpty) return;

  

    // "Top" profile is the last in the list:

    final topProfile = cardData.last;

  

    setState(() {

      cardData.removeLast();

    });

  

    // Send the swipe to the server:

    _sendSwipe(topProfile, swipeValue);

  

    // Reset scroll controller for the new top card:

    _topCardScrollController.dispose();

    _topCardScrollController = ScrollController();

  

    // Prefetch more if needed

    _debouncer.run(() {

      if (mounted && cardData.length <= prefetchThreshold && hasMore) {

        _fetchProfiles();

      }

    });

  }

  

  // IMPORTANT: Adjusted to use "receiver_id" from version 3 (unique Mongo _id),

  // so we send `profileData.topSection.id` instead of the username.

  Future<void> _sendSwipe(

      profile.ProfileData? profileData, String swipeValue) async {

    if (profileData == null) return;

    const storage = FlutterSecureStorage();

    final token = await storage.read(key: 'jwt_token');

    if (token == null) return;

  

    // Using the new swipe.php logic from version 3

    final url = Uri.parse('${Config.backendBaseUrl}/match_algorithm/swipe.php');

  

    // Notice we now set "receiver_id" instead of "receiver_username".

    final body = jsonEncode({

      "receiver_id": profileData.topSection.id,

      "swipe": swipeValue,

    });

  

    try {

      final response = await http.post(

        url,

        headers: {

          "Content-Type": "application/json",

          "Authorization": "Bearer $token",

        },

        body: body,

      );

  

      if (response.statusCode == 200) {

        final cleanedResponse =

            response.body.replaceAll(RegExp(r'<br\s*/?>'), '').trim();

        final responseData = jsonDecode(cleanedResponse);

        final status = responseData["status"];

  

        if (status == "match") {

          debugPrint("It's a match!");

          final String chatId = responseData["chat_id"];

          final String profileURL = responseData["profileURL"];

          final String receiver = responseData["receiver"];

  

          // Possibly navigate to ChatPage:

          Navigator.push(

            context,

            MaterialPageRoute(

              builder: (context) => ChatPage(

                chatId: chatId,

                profileURL: profileURL,

                receiver: receiver,

              ),

            ),

          );

        } else if (status == "no match") {

          debugPrint("No match");

        }

      } else {

        debugPrint(

            "Swipe endpoint error: ${response.statusCode} ${response.body}");

      }

    } catch (e) {

      debugPrint("Error sending swipe: $e");

    }

  }

  

  // -----------------------------------------------------------

  // Gesture Handling: Horizontal vs. Vertical + direction changes

  // -----------------------------------------------------------

  void _onPanStart(DragStartDetails details) {

    _gestureStart = details.globalPosition;

    _decisionMade = false;

    _isHorizontalSwipe = false;

  }

  

  void _onPanUpdate(DragUpdateDetails details) {

    if (_gestureStart == null) return;

  

    final dx = details.globalPosition.dx - _gestureStart!.dx;

    final dy = details.globalPosition.dy - _gestureStart!.dy;

  

    // If we haven't decided whether it's horizontal or vertical, do so now.

    if (!_decisionMade) {

      final distance = math.sqrt(dx * dx + dy * dy);

      if (distance < _slopDistance) return; // Not enough movement yet

      _decisionMade = true;

  

      // If angle <= ~45°, treat it as horizontal => swipe

      final angleDeg = math.atan(dy.abs() / dx.abs()) * (180 / math.pi);

      _isHorizontalSwipe = (angleDeg <= 45);

    }

  

    if (_isHorizontalSwipe) {

      // 1) Update the drag offset

      final current = _dragPositionNotifier.value;

      final newDx = current.dx + details.delta.dx;

      final newDy = current.dy + details.delta.dy * 0.7;

      _dragPositionNotifier.value = Offset(newDx, newDy);

  

      // 2) Determine or switch "direction" based on dx

      _updateSwipeDirection(newDx);

    } else {

      // Vertical scroll logic:

      if (_topCardScrollController.hasClients) {

        final offsetChange = -details.delta.dy;

        final currentOffset = _topCardScrollController.offset;

        final maxExtent = _topCardScrollController.position.maxScrollExtent;

        final newOffset = math.min(

          math.max(currentOffset + offsetChange, 0.0),

          maxExtent,

        );

        _topCardScrollController.jumpTo(newOffset);

      }

    }

  }

  

  /// Switch direction after user crosses more than 2% from the furthest point

  /// in the opposite direction.

  void _updateSwipeDirection(double currentDx) {

    // If we have no direction yet => pick it based on sign of dx

    if (_currentDirection == null) {

      if (currentDx > 0) {

        _currentDirection = "right";

        _furthestRightSoFar = currentDx;

        _furthestLeftSoFar = 0.0;

      } else {

        _currentDirection = "left";

        _furthestLeftSoFar = currentDx;

        _furthestRightSoFar = 0.0;

      }

      return;

    }

  

    // If we are "right":

    if (_currentDirection == "right") {

      // Keep track of the furthest right point

      if (currentDx > _furthestRightSoFar) {

        _furthestRightSoFar = currentDx;

      }

      // Check if user has moved left enough to switch direction

      if (currentDx < 0 &&

          currentDx < (_furthestRightSoFar - directionChangeThreshold)) {

        _currentDirection = "left";

        _furthestLeftSoFar = currentDx;

      }

    }

    // If we are "left":

    else if (_currentDirection == "left") {

      // Keep track of furthest left

      if (currentDx < _furthestLeftSoFar) {

        _furthestLeftSoFar = currentDx;

      }

      // Check if user has moved right enough to switch direction

      if (currentDx > 0 &&

          currentDx > (_furthestLeftSoFar + directionChangeThreshold)) {

        _currentDirection = "right";

        _furthestRightSoFar = currentDx;

      }

    }

  }

  

  void _onPanEnd(DragEndDetails details) {

    // If we ended in horizontal swipe mode:

    if (_isHorizontalSwipe && cardData.isNotEmpty) {

      final offset = _dragPositionNotifier.value;

      final dx = offset.dx;

  

      // If the absolute horizontal offset surpasses the final swipe threshold:

      if (dx.abs() > swipeThreshold) {

        final direction = (dx > 0) ? "yes" : "no";

        _dismissCard(direction);

      }

    } else {

      // If it was vertical scroll, apply momentum:

      if (_topCardScrollController.hasClients) {

        final velocityY = details.velocity.pixelsPerSecond.dy;

        final currentOffset = _topCardScrollController.offset;

        final maxExtent = _topCardScrollController.position.maxScrollExtent;

  

        double targetOffset = currentOffset - velocityY * 0.2;

        targetOffset = math.max(0.0, math.min(targetOffset, maxExtent));

        _topCardScrollController.animateTo(

          targetOffset,

          duration: const Duration(milliseconds: 500),

          curve: Curves.easeOut,

        );

      }

    }

  

    // Always reset horizontal offset and direction states.

    _dragPositionNotifier.value = Offset.zero;

    _gestureStart = null;

    _isHorizontalSwipe = false;

    _decisionMade = false;

    _currentDirection = null;

  }

  

  @override

  void dispose() {

    _dragPositionNotifier.dispose();

    _topCardScrollController.dispose();

    _debouncer.cancel();

    super.dispose();

  }

  

  // REACTION CHAT (from version 2):

  // Called whenever a child element is tapped and wants to open a reaction chat

  void _openReactionChat(Map<String, dynamic> reactionPayload) {

    if (!reactionPayload.containsKey("profile_id")) {

      debugPrint("Missing profile_id in reactionPayload");

    } else {

      debugPrint("Profile ID: ${reactionPayload["profile_id"]}");

    }

    showDialog(

      context: context,

      barrierDismissible: true,

      builder: (context) {

        return ChatPopupDialog(

          reactionPayload: reactionPayload,

        );

      },

    );

  }

  

  @override

  Widget build(BuildContext context) {

    if (!isLoading && cardData.isEmpty) {

      return Container(

        color: AppColors.background,

        child: Center(

          child: Text(

            "No profiles left, change filters",

            style: AppFonts.secondaryFont,

          ),

        ),

      );

    }

  

    if (isLoading) {

      return Container(

        color: AppColors.background,

        child: Center(

          child: Column(

            mainAxisSize: MainAxisSize.min,

            children: [

              SizedBox(width: 200, child: LinearProgressIndicator()),

              const SizedBox(height: 8),

              Text("Loading profiles", style: AppFonts.tertiaryFont),

            ],

          ),

        ),

      );

    }

  

    return Container(

      color: AppColors.background,

      child: SafeArea(

        child: Stack(

          children: [

            // BACK CARD (2nd from top)

            if (visibleCards.length > 1)

              Positioned.fill(

                child: AnimatedScale(

                  duration: const Duration(milliseconds: 200),

                  scale: 0.95,

                  child: ProfileCard(

                    data: visibleCards.first,

                    scrollController: ScrollController(),

                    // from version 2: pass a callback for reacting to elements

                    onElementTap: _openReactionChat,

                  ),

                ),

              ),

  

            // TOP CARD

            if (visibleCards.isNotEmpty)

              Positioned.fill(

                child: GestureDetector(

                  behavior: HitTestBehavior.translucent,

                  onPanStart: _onPanStart,

                  onPanUpdate: _onPanUpdate,

                  onPanEnd: _onPanEnd,

                  child: ValueListenableBuilder<Offset>(

                    valueListenable: _dragPositionNotifier,

                    builder: (context, dragOffset, child) {

                      final dx = dragOffset.dx;

                      // Fade out based on how close dx is to threshold:

                      final factor =

                          (dx.abs() / swipeThreshold).clamp(0.0, 1.0);

                      final opacity = 1.0 - 0.2 * factor;

  

                      return Opacity(

                        opacity: opacity,

                        child: Transform.translate(

                          offset: Offset(dx, dragOffset.dy),

                          child: AnimatedSwitcher(

                            duration: const Duration(milliseconds: 300),

                            transitionBuilder: (child, animation) {

                              return ScaleTransition(

                                scale: Tween<double>(begin: 0.95, end: 1.0)

                                    .animate(

                                  CurvedAnimation(

                                    parent: animation,

                                    curve: Curves.easeOutBack,

                                  ),

                                ),

                                child: child,

                              );

                            },

                            // key uses the top visible card so it only transitions

                            child: RepaintBoundary(

                              key: ValueKey(visibleCards.last),

                              child: ProfileCard(

                                data: visibleCards.last,

                                scrollController: _topCardScrollController,

                                onElementTap: _openReactionChat,

                              ),

                            ),

                          ),

                        ),

                      );

                    },

                  ),

                ),

              ),

  

            // YES/NO indicators (optional from version 1)

            SwipeIndicators(

              dragNotifier: _dragPositionNotifier,

              swipeThreshold: swipeThreshold,

            ),

  

            // Loading indicator if fetching more

            if (isFetchingMore)

              const Positioned(

                bottom: 20,

                left: 0,

                right: 0,

                child: Center(

                  child: Column(

                    mainAxisSize: MainAxisSize.min,

                    children: [

                      CircularProgressIndicator(),

                      SizedBox(height: 8),

                      Text("New profiles loading"),

                    ],

                  ),

                ),

              ),

          ],

        ),

      ),

    );

  }

}

  

/// Displays a translucent "check" or "close" as the user drags horizontally.

class SwipeIndicators extends StatelessWidget {

  final ValueNotifier<Offset> dragNotifier;

  final double swipeThreshold;

  

  const SwipeIndicators({

    Key? key,

    required this.dragNotifier,

    required this.swipeThreshold,

  }) : super(key: key);

  

  @override

  Widget build(BuildContext context) {

    return ValueListenableBuilder<Offset>(

      valueListenable: dragNotifier,

      builder: (context, offset, child) {

        final dx = offset.dx;

        final dy = offset.dy;

  

        final isHorizontal = dx.abs() >= dy.abs();

        final progress = (dx.abs() / swipeThreshold).clamp(0.0, 1.0);

        final leftOpacity = (dx < 0 && isHorizontal) ? progress : 0.0;

        final rightOpacity = (dx > 0 && isHorizontal) ? progress : 0.0;

  

        final screenHeight = MediaQuery.of(context).size.height;

        final verticalPosition = screenHeight / 2 - 30;

  

        return IgnorePointer(

          child: Stack(

            children: [

              // NO indicator (left)

              Positioned(

                left: 20,

                top: verticalPosition,

                child: AnimatedOpacity(

                  opacity: leftOpacity,

                  duration: const Duration(milliseconds: 100),

                  child: CircleAvatar(

                    radius: 30,

                    backgroundColor: Colors.red.withOpacity(0.9),

                    child:

                        const Icon(Icons.close, color: Colors.white, size: 30),

                  ),

                ),

              ),

              // YES indicator (right)

              Positioned(

                right: 20,

                top: verticalPosition,

                child: AnimatedOpacity(

                  opacity: rightOpacity,

                  duration: const Duration(milliseconds: 100),

                  child: CircleAvatar(

                    radius: 30,

                    backgroundColor: Colors.green.withOpacity(0.9),

                    child:

                        const Icon(Icons.check, color: Colors.white, size: 30),

                  ),

                ),

              ),

            ],

          ),

        );

      },

    );

  }

}

  

/// Simple Debouncer for prefetch logic.

class Debouncer {

  final int milliseconds;

  Timer? _timer;

  

  Debouncer({required this.milliseconds});

  

  void run(VoidCallback action) {

    _timer?.cancel();

    _timer = Timer(Duration(milliseconds: milliseconds), action);

  }

  

  void cancel() {

    _timer?.cancel();

  }

}
"


swipe.php:

"
<?php

require __DIR__ . '/../../vendor/autoload.php';

require_once __DIR__ . '/../config.php';

  

use Firebase\JWT\JWT;

use Firebase\JWT\Key;

use MongoDB\BSON\ObjectId;

  

header('Content-Type: application/json');

ini_set('display_errors', 1);

ini_set('display_startup_errors', 1);

error_reporting(E_ALL);

  

// Only allow POST requests.

if ($_SERVER['REQUEST_METHOD'] !== 'POST') {

    http_response_code(405);

    echo json_encode(["status" => "error", "message" => "Method not allowed"]);

    exit;

}

  

// Retrieve JWT from the Authorization header.

$headers = getallheaders();

if (!isset($headers['Authorization'])) {

    http_response_code(401);

    echo json_encode(["status" => "error", "message" => "Missing Authorization header"]);

    exit;

}

$authHeader = $headers['Authorization'];

if (strpos($authHeader, "Bearer ") !== 0) {

    http_response_code(401);

    echo json_encode(["status" => "error", "message" => "Invalid Authorization header"]);

    exit;

}

$jwtToken = trim(str_replace("Bearer ", "", $authHeader));

  

$secretKey = "hJU7ncW+5udrBQa6MBjSxwjcZikYwVtAzUquG9jFGX8GQ4I5j0IQU2QNOEtFX3qjl4odFvAsuD6Ah7Qt57nZSA==";

  

try {

    $decodedToken = JWT::decode($jwtToken, new Key($secretKey, 'HS256'));

    $senderId = $decodedToken->user_id ?? null;

} catch(Exception $e) {

    http_response_code(401);

    echo json_encode(["status" => "error", "message" => "Invalid token"]);

    exit;

}

if (!$senderId) {

    http_response_code(401);

    echo json_encode(["status" => "error", "message" => "Invalid token"]);

    exit;

}

  

// Connect to MongoDB and get sender (swiper) information.

$mongoManager = new MongoDB\Driver\Manager($mongoURI);

$senderFilter = ['_id' => new ObjectId($senderId)];

$senderQuery = new MongoDB\Driver\Query($senderFilter);

$senderCursor = $mongoManager->executeQuery("swipe_chat_play.users", $senderQuery);

$sender = current($senderCursor->toArray());

if (!$sender) {

    http_response_code(404);

    echo json_encode(["status" => "error", "message" => "Sender not found"]);

    exit;

}

  

// Get JSON input.

$input = json_decode(file_get_contents('php://input'), true);

$inputReceiverId = $input['receiver_id'] ?? null; // Now using the unique id directly

$swipeValue = $input['swipe'] ?? null;

if (!$inputReceiverId || !$swipeValue) {

    http_response_code(400);

    echo json_encode(["status" => "error", "message" => "receiver_id and swipe are required"]);

    exit;

}

  

// Look up the receiver by _id.

$receiverFilter = ['_id' => new ObjectId($inputReceiverId)];

$receiverQuery = new MongoDB\Driver\Query($receiverFilter);

$receiverCursor = $mongoManager->executeQuery("swipe_chat_play.users", $receiverQuery);

$receiver = current($receiverCursor->toArray());

if (!$receiver) {

    http_response_code(404);

    echo json_encode(["status" => "error", "message" => "Receiver not found"]);

    exit;

}

$receiverId = (string)$receiver->_id;

  

// Build query filter using sender and receiver IDs (used as keys in the match document)

$queryFilter = [

    "users.$senderId"   => ['$exists' => true],

    "users.$receiverId" => ['$exists' => true]

];

$query = new MongoDB\Driver\Query($queryFilter);

$cursor = $mongoManager->executeQuery("swipe_chat_play.matches", $query);

$matchDoc = current($cursor->toArray());

$bulk = new MongoDB\Driver\BulkWrite();

  

if ($matchDoc) {

    // Update the current user’s (swiper’s) swipe.

    $updateField = "users.$senderId";

    $bulk->update(

        ['_id' => $matchDoc->_id],

        ['$set' => [$updateField => $swipeValue]],

        ['multi' => false, 'upsert' => false]

    );

    $mongoManager->executeBulkWrite("swipe_chat_play.matches", $bulk);

  

    // Re-read the document to check the swipe status.

    $query = new MongoDB\Driver\Query(['_id' => $matchDoc->_id]);

    $cursor = $mongoManager->executeQuery("swipe_chat_play.matches", $query);

    $updatedDoc = current($cursor->toArray());

    $users = $updatedDoc->users;

    $swiperSwipe = $users->$senderId ?? null;

    $swipedSwipe = $users->$receiverId ?? null;

  

    if ($swiperSwipe === "yes" && $swipedSwipe === "yes") {

        // OPTIONAL: Check if a chat was already created to avoid duplicates.

        if (isset($updatedDoc->chat_id)) {

            // Return the already created chat details.

            echo json_encode([

                "status" => "match",

                "chat_id" => $updatedDoc->chat_id,

                "profileURL" => $updatedDoc->receiver_profileURL ?? "",

                "receiver_id" => $receiverId,

                "receiver" => $receiver->username

            ]);

            exit;

        }

  

        // Fetch receiver information and extract profile image.

        $receiverProfileImage = "";

        if (isset($receiver->profile)) {

            if (is_string($receiver->profile)) {

                $receiverProfile = json_decode($receiver->profile, true);

            } else {

                $receiverProfile = (array)$receiver->profile;

            }

            $receiverProfileImage = $receiverProfile['images'][0] ?? "";

        }

        $senderProfileImage = "";

        if (isset($sender->profile)) {

            if (is_string($sender->profile)) {

                $senderProfile = json_decode($sender->profile, true);

            } else {

                $senderProfile = (array)$sender->profile;

            }

            $senderProfileImage = $senderProfile['images'][0] ?? "";

        }

  

        // Create chat document.

        $chatData = [

            "messages" => new \stdClass(),

            "participants" => [$senderId, $receiverId]

        ];

        $bulkChat = new MongoDB\Driver\BulkWrite();

        $chatId = $bulkChat->insert($chatData);

        $mongoManager->executeBulkWrite("swipe_chat_play.chats", $bulkChat);

        $chatIdString = (string)$chatId;

  

        // Prepare chat metadata.

        // For the sender, store the receiver's unique id under "receiver_id" and its username under "receiver".

        $chatMetaSender = [

            "profileURL"   => $receiverProfileImage,

            "receiver_id"  => $receiverId,

            "receiver"     => $receiver->username,

            "last_message" => "",

            "unread"       => 0

        ];

        // For the receiver, store the sender's unique id under "receiver_id" and its username under "receiver".

        $chatMetaReceiver = [

            "profileURL"   => $senderProfileImage,

            "receiver_id"  => $senderId,

            "receiver"     => $sender->username,

            "last_message" => "",

            "unread"       => 0

        ];

  

        // Update sender's and receiver's chat lists.

        $bulkUpdate = new MongoDB\Driver\BulkWrite();

        $bulkUpdate->update(

            ["_id" => new ObjectId($senderId)],

            ['$set' => ["chats.$chatIdString" => $chatMetaSender]]

        );

        $bulkUpdate->update(

            ["_id" => new ObjectId($receiverId)],

            ['$set' => ["chats.$chatIdString" => $chatMetaReceiver]]

        );

        $mongoManager->executeBulkWrite("swipe_chat_play.users", $bulkUpdate);

  

        // OPTIONAL: Update the match document with chat details to avoid duplicate creation.

        $bulkMatchUpdate = new MongoDB\Driver\BulkWrite();

        $bulkMatchUpdate->update(

            ['_id' => $updatedDoc->_id],

            ['$set' => [

                "chat_id" => $chatIdString,

                "receiver_profileURL" => $receiverProfileImage

            ]]

        );

        $mongoManager->executeBulkWrite("swipe_chat_play.matches", $bulkMatchUpdate);

  

        echo json_encode([

            "status" => "match",

            "chat_id" => $chatIdString,

            "profileURL" => $receiverProfileImage,

            "receiver_id" => $receiverId,

            "receiver" => $receiver->username

        ]);

    } elseif ($swiperSwipe === "no" || $swipedSwipe === "no") {

        echo json_encode(["status" => "no match"]);

    } else {

        // One swipe is still pending.

        echo json_encode(["status" => "no match"]);

    }

} else {

    // No document exists yet; create one with both user IDs.

    $newDoc = [

        "users" => [

            $senderId   => $swipeValue,

            $receiverId => null

        ]

    ];

    $bulk->insert($newDoc);

    $mongoManager->executeBulkWrite("swipe_chat_play.matches", $bulk);

    echo json_encode(["status" => "no match"]);

}

?>
"

